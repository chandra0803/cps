/*
 *
 * $Id: OTCallableStatement.java,v 1.2 2004/11/19 15:23:24 zz0qx3 Exp $
 * $Revision: 1.2 $
 * $Log: OTCallableStatement.java,v $
 * Revision 1.2  2004/11/19 15:23:24  zz0qx3
 * added 1.4 required methods
 *
 * Revision 1.1  2004/08/23 20:30:25  vz86k2
 * check in
 *
 */

package com.delphi.gfad.coreframework.db;

import java.sql.*;
import java.math.*;
import java.util.*;
import java.net.URL;
import java.io.*;

public class OTCallableStatement extends OTPreparedStatement implements CallableStatement
{




  private CallableStatement getProxy()
  {
    return(CallableStatement)proxy;
  }


  public OTCallableStatement(CallableStatement proxy,boolean isCaching)
  {
    super(proxy,isCaching);
  }
  /**
   * Executes the SQL INSERT, UPDATE or DELETE statement
       * in this <code>PreparedStatement</code> object.
       * In addition,
   * SQL statements that return nothing, such as SQL DDL statements,
   * can be executed.
   *
   * @return either the row count for INSERT, UPDATE or DELETE statements;
       * or 0 for SQL statements that return nothing
   * @exception SQLException if a database access error occurs
   */
  public int executeUpdate() throws SQLException {
    return getProxy().executeUpdate();
  }
  /**
       * Executes the SQL query in this <code>PreparedStatement</code> object
       * and returns the result set generated by the query.
   *
   * @return a <code>ResultSet</code> object that contains the data produced by the
   * query; never <code>null</code>
   * @exception SQLException if a database access error occurs
   */
  public ResultSet executeQuery() throws SQLException {
    return getProxy().executeQuery();
  }
  /**
   * Sets the designated parameter to a Java <code>double</code> value.
       * The driver converts this
   * to an SQL <code>DOUBLE</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setDouble(int parameterIndex, double x) throws SQLException {
    getProxy().setDouble(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java <code>short</code> value.
       * The driver converts this
   * to an SQL <code>SMALLINT</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setShort(int parameterIndex, short x) throws SQLException {
    getProxy().setShort(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to SQL <code>NULL</code>.
   *
   * <P><B>Note:</B> You must specify the parameter's SQL type.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param sqlType the SQL type code defined in <code>java.sql.Types</code>
   * @exception SQLException if a database access error occurs
   */
  public void setNull(int parameterIndex, int sqlType) throws SQLException {
    getProxy().setNull(parameterIndex,sqlType);
  }
  /**
   * Sets the designated parameter to a Java <code>boolean</code> value.
       * The driver converts this
   * to an SQL <code>BIT</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setBoolean(int parameterIndex, boolean x) throws SQLException {
    getProxy().setBoolean(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java <code>byte</code> value.
       * The driver converts this
   * to an SQL <code>TINYINT</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setByte(int parameterIndex, byte x) throws SQLException {
    getProxy().setByte(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a <code<java.sql.Date</code> value.
       * The driver converts this
   * to an SQL <code>DATE</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setDate(int parameterIndex, java.sql.Date x) throws SQLException {
    getProxy().setDate(parameterIndex,x);
  }

  /**
   * Sets the designated parameter to a Java <code>int</code> value.
       * The driver converts this
   * to an SQL <code>INTEGER</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setInt(int parameterIndex, int x) throws SQLException {
    getProxy().setInt(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java <code>long</code> value.
       * The driver converts this
   * to an SQL <code>BIGINT</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setLong(int parameterIndex, long x) throws SQLException {
    getProxy().setLong(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java <code>float</code> value.
       * The driver converts this
   * to an SQL <code>FLOAT</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setFloat(int parameterIndex, float x) throws SQLException {
    getProxy().setFloat(parameterIndex,x);
  }
  /**
       * Sets the designated parameter to the given input stream, which will have
       * the specified number of bytes.
   * When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
   * parameter, it may be more practical to send it via a
   * <code>java.io.InputStream</code> object. The data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from UNICODE to the database char format.
       * The byte format of the Unicode stream must be Java UTF-8, as
       * defined in the Java Virtual Machine Specification.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the java input stream which contains the
   * UNICODE parameter value
   * @param length the number of bytes in the stream
   * @exception SQLException if a database access error occurs
   * @deprecated
   */
  public void setUnicodeStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
    getProxy().setUnicodeStream(parameterIndex,x,length);
  }
  /**
   * Sets the designated parameter to a <code>java.math.BigDecimal</code> value.
   * The driver converts this to an SQL <code>NUMERIC</code> value when
   * it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
    getProxy().setBigDecimal(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java <code>String</code> value.
       * The driver converts this
   * to an SQL <code>VARCHAR</code> or <code>LONGVARCHAR</code> value
       * (depending on the argument's
   * size relative to the driver's limits on <code>VARCHAR</code> values)
       * when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setString(int parameterIndex, String x) throws SQLException {
    getProxy().setString(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java array of bytes.  The driver converts
   * this to an SQL <code>VARBINARY</code> or <code>LONGVARBINARY</code>
       * (depending on the argument's size relative to the driver's limits on
       * <code>VARBINARY</code> values) when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setBytes(int parameterIndex, byte x[]) throws SQLException {
    getProxy().setBytes(parameterIndex,x);
  }
  /**
        * Sets the value of the designated parameter with the given object.
    * This method is like the method <code>setObject</code>
        * above, except that it assumes a scale of zero.
    *
    * @param parameterIndex the first parameter is 1, the second is 2, ...
    * @param x the object containing the input parameter value
    * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
    *                      sent to the database
    * @exception SQLException if a database access error occurs
    */
  public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
    getProxy().setObject(parameterIndex,x,targetSqlType);
  }
  /**
   * Sets the designated parameter to a <code>java.sql.Time</code> value.
       * The driver converts this
   * to an SQL <code>TIME</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setTime(int parameterIndex, java.sql.Time x) throws SQLException {
    getProxy().setTime(parameterIndex,x);
  }

  /**
   * Sets the designated parameter to a <code>java.sql.Timestamp</code> value.
       * The driver
   * converts this to an SQL <code>TIMESTAMP</code> value when it sends it to the
   * database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setTimestamp(int parameterIndex, java.sql.Timestamp x) throws SQLException {
    getProxy().setTimestamp(parameterIndex,x);
  }
  /**
       * Sets the designated parameter to the given input stream, which will have
       * the specified number of bytes.
   * When a very large ASCII value is input to a <code>LONGVARCHAR</code>
   * parameter, it may be more practical to send it via a
   * <code>java.io.InputStream</code>. Data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from ASCII to the database char format.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the Java input stream that contains the ASCII parameter value
   * @param length the number of bytes in the stream
   * @exception SQLException if a database access error occurs
   */
  public void setAsciiStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
    getProxy().setAsciiStream(parameterIndex,x,length);
  }
  /**
       * Sets the designated parameter to the given <code>Reader</code>
       * object, which is the given number of characters long.
   * When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
   * parameter, it may be more practical to send it via a
   * <code>java.io.Reader</code> object. The data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from UNICODE to the database char format.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the java reader which contains the UNICODE data
   * @param length the number of characters in the stream
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setCharacterStream(int parameterIndex, java.io.Reader reader, int length) throws SQLException {
    getProxy().setCharacterStream(parameterIndex,reader,length);
  }
  /**
       * Sets the designated parameter to the given input stream, which will have
       * the specified number of bytes.
   * When a very large binary value is input to a <code>LONGVARBINARY</code>
   * parameter, it may be more practical to send it via a
   * <code>java.io.InputStream</code> object. The data will be read from the stream
   * as needed until end-of-file is reached.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the java input stream which contains the binary parameter value
   * @param length the number of bytes in the stream
   * @exception SQLException if a database access error occurs
   */
  public void setBinaryStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
    getProxy().setBinaryStream(parameterIndex,x,length);
  }
  /**
       * Clears the current parameter values immediately.
   * <P>In general, parameter values remain in force for repeated use of a
   * statement. Setting a parameter value automatically clears its
   * previous value.  However, in some cases it is useful to immediately
   * release the resources used by the current parameter values; this can
   * be done by calling the method <code>clearParameters</code>.
   *
   * @exception SQLException if a database access error occurs
   */
  public void clearParameters() throws SQLException {
    getProxy().clearParameters();
  }
  /**
   * <p>Sets the value of the designated parameter with the given object. The second
       * argument must be an object type; for integral values, the
   * <code>java.lang</code> equivalent objects should be used.
   *
   * <p>The given Java object will be converted to the given targetSqlType
   * before being sent to the database.
   *
   * If the object has a custom mapping (is of a class implementing the
       * interface <code>SQLData</code>),
   * the JDBC driver should call the method <code>SQLData.writeSQL</code> to write it
   * to the SQL data stream.
   * If, on the other hand, the object is of a class implementing
       * Ref, Blob, Clob, Struct,
   * or Array, the driver should pass it to the database as a value of the
   * corresponding SQL type.
   *
   * <p>Note that this method may be used to pass datatabase-
   * specific abstract data types.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the object containing the input parameter value
   * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
   * sent to the database. The scale argument may further qualify this type.
   * @param scale for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,
   *          this is the number of digits after the decimal point.  For all other
   *          types, this value will be ignored.
   * @exception SQLException if a database access error occurs
   * @see Types
   */
  public void setObject(int parameterIndex, Object x, int targetSqlType, int scale) throws SQLException {
    getProxy().setObject(parameterIndex,x,targetSqlType,scale);
  }
  /**
   * Sets the designated parameter to the given
       *  <code>Array</code> object.
   * Sets an Array parameter.
   *
   * @param i the first parameter is 1, the second is 2, ...
   * @param x an <code>Array</code> object that maps an SQL <code>ARRAY</code> value
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setArray(int i, Array x) throws SQLException {
    getProxy().setArray(i,x);
  }
  /**
   * <p>Sets the value of the designated parameter using the given object.
       * The second parameter must be of type <code>Object</code>; therefore, the
   * <code>java.lang</code> equivalent objects should be used for built-in types.
   *
   * <p>The JDBC specification specifies a standard mapping from
   * Java <code>Object</code> types to SQL types.  The given argument
   * will be converted to the corresponding SQL type before being
   * sent to the database.
   *
   * <p>Note that this method may be used to pass datatabase-
   * specific abstract data types, by using a driver-specific Java
   * type.
   *
   * If the object is of a class implementing the interface <code>SQLData</code>,
   * the JDBC driver should call the method <code>SQLData.writeSQL</code>
       * to write it to the SQL data stream.
   * If, on the other hand, the object is of a class implementing
       * Ref, Blob, Clob, Struct,
   * or Array, then the driver should pass it to the database as a value of the
   * corresponding SQL type.
   *
   * This method throws an exception if there is an ambiguity, for example, if the
   * object is of a class implementing more than one of the interfaces named above.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the object containing the input parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setObject(int parameterIndex, Object x) throws SQLException {
    getProxy().setObject(parameterIndex,x);
  }
  /**
       * Executes any kind of SQL statement.
   * Some prepared statements return multiple results; the <code>execute</code>
   * method handles these complex statements as well as the simpler
   * form of statements handled by the methods <code>executeQuery</code>
       * and <code>executeUpdate</code>.
   *
   * @exception SQLException if a database access error occurs
   * @see Statement#execute
   */
  public boolean execute() throws SQLException {
    return getProxy().execute();
  }
  /**
   * Adds a set of parameters to this <code>PreparedStatement</code>
       * object's batch of commands.
   *
   * @exception SQLException if a database access error occurs
   * @see Statement#addBatch
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void addBatch() throws SQLException {
    getProxy().addBatch();
  }
  /**
   * Sets the designated parameter to the given
       *  <code>REF(&lt;structured-type&gt;)</code> value.
   *
   * @param i the first parameter is 1, the second is 2, ...
   * @param x an SQL <code>REF</code> value
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setRef(int i, Ref x) throws SQLException {
    getProxy().setRef(i,x);
  }
  /**
   * Sets the designated parameter to the given
       *  <code>Blob</code> object.
   *
   * @param i the first parameter is 1, the second is 2, ...
   * @param x a <code>Blob</code> object that maps an SQL <code>BLOB</code> value
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setBlob(int i, Blob x) throws SQLException {
    getProxy().setBlob(i,x);
  }
  /**
   * Sets the designated parameter to the given
       *  <code>Clob</code> object.
   *
   * @param i the first parameter is 1, the second is 2, ...
   * @param x a <code>Clob</code> object that maps an SQL <code>CLOB</code> value
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setClob(int i, Clob x) throws SQLException {
    getProxy().setClob(i,x);
  }
  /**
   * Gets the number, types and properties of a <code>ResultSet</code>
       * object's columns.
   *
   * @return the description of a <code>ResultSet</code> object's columns
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public ResultSetMetaData getMetaData() throws SQLException {
    return getProxy().getMetaData();
  }
  /**
   * Executes an SQL statement that returns a single <code>ResultSet</code> object.
   *
   * @param sql typically this is a static SQL <code>SELECT</code> statement
   * @return a <code>ResultSet</code> object that contains the data produced by the
   * given query; never <code>null</code>
   * @exception SQLException if a database access error occurs
   */
  public ResultSet executeQuery(String sql) throws SQLException {
    return getProxy().executeQuery(sql);
  }
  /**
   * Executes an SQL <code>INSERT</code>, <code>UPDATE</code> or
       * <code>DELETE</code> statement. In addition,
   * SQL statements that return nothing, such as SQL DDL statements,
   * can be executed.
   *
   * @param sql an SQL <code>INSERT</code>, <code>UPDATE</code> or
       * <code>DELETE</code> statement or an SQL statement that returns nothing
   * @return either the row count for <code>INSERT</code>, <code>UPDATE</code>
       * or <code>DELETE</code> statements, or 0 for SQL statements that return nothing
   * @exception SQLException if a database access error occurs
   */
  public int executeUpdate(String sql) throws SQLException {
    return getProxy().executeUpdate(sql);
  }
  /**
   * Retrieves the maximum number of rows that a
   * <code>ResultSet</code> object can contain.  If the limit is exceeded, the excess
   * rows are silently dropped.
   *
   * @return the current max row limit; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public int getMaxRows() throws SQLException {
    return getProxy().getMaxRows();
  }
  /**
       * Releases this <code>Statement</code> object's database
       * and JDBC resources immediately instead of waiting for
       * this to happen when it is automatically closed.
   * It is generally good practice to release resources as soon as
       * you are finished with them to avoid tying up database
       * resources.
   * <P><B>Note:</B> A <code>Statement</code> object is automatically closed when it is
   * garbage collected. When a <code>Statement</code> object is closed, its current
   * <code>ResultSet</code> object, if one exists, is also closed.
   *
   * @exception SQLException if a database access error occurs
   */
  public void close() throws SQLException {
    if (!isCaching())
      getProxy().close();
  }
  /**
       * Sets escape processing on or off.
   * If escape scanning is on (the default), the driver will do
   * escape substitution before sending the SQL to the database.
   *
   * Note: Since prepared statements have usually been parsed prior
   * to making this call, disabling escape processing for prepared
   * statements will have no effect.
   *
   * @param enable <code>true</code> to enable; <code>false</code> to disable
   * @exception SQLException if a database access error occurs
   */
  public void setEscapeProcessing(boolean enable) throws SQLException {
    getProxy().setEscapeProcessing(enable);
  }
  /**
   * Returns the maximum number of bytes allowed
   * for any column value.
       * This limit is the maximum number of bytes that can be
       * returned for any column value.
       * The limit applies only to <code>BINARY</code>,
   * <code>VARBINARY</code>, <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>, and <code>LONGVARCHAR</code>
   * columns.  If the limit is exceeded, the excess data is silently
   * discarded.
   *
   * @return the current max column size limit; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public int getMaxFieldSize() throws SQLException {
    return getProxy().getMaxFieldSize();
  }
  /**
       * Sets the limit for the maximum number of bytes in a column to
       * the given number of bytes.  This is the maximum number of bytes
       * that can be returned for any column value.  This limit applies
       * only to <code>BINARY</code>, <code>VARBINARY</code>,
       * <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>, and
   * <code>LONGVARCHAR</code> fields.  If the limit is exceeded, the excess data
   * is silently discarded. For maximum portability, use values
   * greater than 256.
   *
   * @param max the new max column size limit; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public void setMaxFieldSize(int max) throws SQLException {
    getProxy().setMaxFieldSize(max);
  }
  /**
   * Sets the number of seconds the driver will
   * wait for a <code>Statement</code> object to execute to the given number of seconds.
       * If the limit is exceeded, an <code>SQLException</code> is thrown.
   *
   * @param seconds the new query timeout limit in seconds; zero means
   * unlimited
   * @exception SQLException if a database access error occurs
   */
  public void setQueryTimeout(int seconds) throws SQLException {
    getProxy().setQueryTimeout(seconds);
  }
  /**
   * Sets the limit for the maximum number of rows that any
   * <code>ResultSet</code> object can contain to the given number.
       * If the limit is exceeded, the excess
   * rows are silently dropped.
   *
   * @param max the new max rows limit; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public void setMaxRows(int max) throws SQLException {
    getProxy().setMaxRows(max);
  }
  /**
   * Retrieves the first warning reported by calls on this <code>Statement</code> object.
   * Subsequent <code>Statement</code> object warnings will be chained to this
   * <code>SQLWarning</code> object.
   *
   * <p>The warning chain is automatically cleared each time
   * a statement is (re)executed.
   *
   * <P><B>Note:</B> If you are processing a <code>ResultSet</code> object, any
   * warnings associated with reads on that <code>ResultSet</code> object
       * will be chained on it.
   *
   * @return the first <code>SQLWarning</code> object or <code>null</code>
   * @exception SQLException if a database access error occurs
   */
  public SQLWarning getWarnings() throws SQLException {
    return getProxy().getWarnings();
  }
  /**
       * Retrieves the number of seconds the driver will
   * wait for a <code>Statement</code> object to execute. If the limit is exceeded, a
   * <code>SQLException</code> is thrown.
   *
   * @return the current query timeout limit in seconds; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public int getQueryTimeout() throws SQLException {
    return getProxy().getQueryTimeout();
  }
  /**
   * Defines the SQL cursor name that will be used by
   * subsequent <code>Statement</code> object <code>execute</code> methods.
       * This name can then be
   * used in SQL positioned update/delete statements to identify the
   * current row in the <code>ResultSet</code> object generated by this statement.  If
   * the database doesn't support positioned update/delete, this
   * method is a noop.  To insure that a cursor has the proper isolation
   * level to support updates, the cursor's <code>SELECT</code> statement should be
   * of the form 'select for update ...'. If the 'for update' phrase is
   * omitted, positioned updates may fail.
   *
   * <P><B>Note:</B> By definition, positioned update/delete
   * execution must be done by a different <code>Statement</code> object than the one
   * which generated the <code>ResultSet</code> object being used for positioning. Also,
   * cursor names must be unique within a connection.
   *
   * @param name the new cursor name, which must be unique within
       *             a connection
   * @exception SQLException if a database access error occurs
   */
  public void setCursorName(String name) throws SQLException {
    getProxy().setCursorName(name);
  }
  /**
       * Cancels this <code>Statement</code> object if both the DBMS and
       * driver support aborting an SQL statement.
   * This method can be used by one thread to cancel a statement that
   * is being executed by another thread.
   *
   * @exception SQLException if a database access error occurs
   */
  public void cancel() throws SQLException {
    getProxy().cancel();
  }
  /**
   *  Returns the current result as a <code>ResultSet</code> object.
   *  This method should be called only once per result.
   *
   * @return the current result as a <code>ResultSet</code> object;
       * <code>null</code> if the result is an update count or there are no more results
   * @exception SQLException if a database access error occurs
   * @see #execute
   */
  public ResultSet getResultSet() throws SQLException {
    return getProxy().getResultSet();
  }
  /**
       * Clears all the warnings reported on this <code>Statement</code>
       * object. After a call to this method,
       * the method <code>getWarnings</code> will return
       * <code>null</code> until a new warning is reported for this
       * <code>Statement</code> object.
   *
   * @exception SQLException if a database access error occurs
   */
  public void clearWarnings() throws SQLException {
    getProxy().clearWarnings();
  }
  /**
   * Moves to a <code>Statement</code> object's next result.  It returns
       * <code>true</code> if this result is a <code>ResultSet</code> object.
       * This method also implicitly closes any current <code>ResultSet</code>
       * object obtained with the method <code>getResultSet</code>.
   *
   * <P>There are no more results when the following is true:
       * <PRE>
       *      <code>(!getMoreResults() && (getUpdateCount() == -1)</code>
       * </PRE>
   *
   * @return <code>true</code> if the next result is a <code>ResultSet</code> object;
       * <code>false</code> if it is an update count or there are no more results
   * @exception SQLException if a database access error occurs
   * @see #execute
   */
  public boolean getMoreResults() throws SQLException {
    return getProxy().getMoreResults();
  }
  /**
   * Executes an SQL statement that may return multiple results.
   * Under some (uncommon) situations a single SQL statement may return
   * multiple result sets and/or update counts.  Normally you can ignore
   * this unless you are (1) executing a stored procedure that you know may
   * return multiple results or (2) you are dynamically executing an
   * unknown SQL string.  The  methods <code>execute</code>,
       * <code>getMoreResults</code>, <code>getResultSet</code>,
   * and <code>getUpdateCount</code> let you navigate through multiple results.
   *
   * The <code>execute</code> method executes an SQL statement and indicates the
   * form of the first result.  You can then use the methods
       * <code>getResultSet</code> or <code>getUpdateCount</code>
       * to retrieve the result, and <code>getMoreResults</code> to
   * move to any subsequent result(s).
   *
   * @param sql any SQL statement
   * @return <code>true</code> if the next result is a <code>ResultSet</code> object;
       * <code>false</code> if it is an update count or there are no more results
   * @exception SQLException if a database access error occurs
   * @see #getResultSet
   * @see #getUpdateCount
   * @see #getMoreResults
   */
  public boolean execute(String sql) throws SQLException {
    return getProxy().execute(sql);
  }
  /**
   * Retrieves the direction for fetching rows from
       * database tables that is the default for result sets
       * generated from this <code>Statement</code> object.
       * If this <code>Statement</code> object has not set
       * a fetch direction by calling the method <code>setFetchDirection</code>,
       * the return value is implementation-specific.
   *
   * @return the default fetch direction for result sets generated
       *          from this <code>Statement</code> object
   * @exception SQLException if a database access error occurs
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public int getFetchDirection() throws SQLException {
    return getProxy().getFetchDirection();
  }
  /**
   *  Returns the current result as an update count;
   *  if the result is a <code>ResultSet</code> object or there are no more results, -1
   *  is returned. This method should be called only once per result.
   *
   * @return the current result as an update count; -1 if the current result is a
   * <code>ResultSet</code> object or there are no more results
   * @exception SQLException if a database access error occurs
   * @see #execute
   */
  public int getUpdateCount() throws SQLException {
    return getProxy().getUpdateCount();
  }
  /**
   * Retrieves the number of result set rows that is the default
       * fetch size for result sets
       * generated from this <code>Statement</code> object.
       * If this <code>Statement</code> object has not set
       * a fetch size by calling the method <code>setFetchSize</code>,
       * the return value is implementation-specific.
   * @return the default fetch size for result sets generated
       *          from this <code>Statement</code> object
   * @exception SQLException if a database access error occurs
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public int getFetchSize() throws SQLException {
    return getProxy().getFetchSize();
  }
  /**
   * Gives the driver a hint as to the direction in which
       * the rows in a result set
   * will be processed. The hint applies only to result sets created
   * using this <code>Statement</code> object.  The default value is
   * <code>ResultSet.FETCH_FORWARD</code>.
   * <p>Note that this method sets the default fetch direction for
       * result sets generated by this <code>Statement</code> object.
       * Each result set has its own methods for getting and setting
       * its own fetch direction.
   * @param direction the initial direction for processing rows
   * @exception SQLException if a database access error occurs
       * or the given direction
   * is not one of <code>ResultSet.FETCH_FORWARD</code>,
       * <code>ResultSet.FETCH_REVERSE</code>, or <code>ResultSet.FETCH_UNKNOWN</code>
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setFetchDirection(int direction) throws SQLException {
    getProxy().setFetchDirection(direction);
  }
  /**
   * Retrieves the result set type for <code>ResultSet</code> objects
       * generated by this <code>Statement</code> object.
       *
       * @return one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
       * <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
       * <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public int getResultSetType() throws SQLException {
    return getProxy().getResultSetType();
  }
  /**
   * Gives the JDBC driver a hint as to the number of rows that should
   * be fetched from the database when more rows are needed.  The number
   * of rows specified affects only result sets created using this
   * statement. If the value specified is zero, then the hint is ignored.
   * The default value is zero.
   *
   * @param rows the number of rows to fetch
   * @exception SQLException if a database access error occurs, or the
   * condition 0 <= rows <= this.getMaxRows() is not satisfied.
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setFetchSize(int rows) throws SQLException {
    getProxy().setFetchSize(rows);
  }
  /**
   * Makes the set of commands in the current batch empty.
   * This method is optional.
   *
   * @exception SQLException if a database access error occurs or the
   * driver does not support batch statements
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void clearBatch() throws SQLException {
    getProxy().clearBatch();
  }
  /**
   * Retrieves the result set concurrency for <code>ResultSet</code> objects
       * generated by this <code>Statement</code> object.
       *
       * @return either <code>ResultSet.CONCUR_READ_ONLY</code> or
       * <code>ResultSet.CONCUR_UPDATABLE</code>
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public int getResultSetConcurrency() throws SQLException {
    return getProxy().getResultSetConcurrency();
  }
  /**
   * Returns the <code>Connection</code> object
       * that produced this <code>Statement</code> object.
       * @return the connection that produced this statement
   * @exception SQLException if a database access error occurs
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public Connection getConnection() throws SQLException {
    return getProxy().getConnection();
  }
  /**
   * Adds an SQL command to the current batch of commmands for this
       * <code>Statement</code> object. This method is optional.
   *
   * @param sql typically this is a static SQL <code>INSERT</code> or
       * <code>UPDATE</code> statement
   * @exception SQLException if a database access error occurs, or the
   * driver does not support batch statements
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void addBatch(String sql) throws SQLException {
    getProxy().addBatch(sql);
  }
  /**
   * Submits a batch of commands to the database for execution and
       * if all commands execute successfully, returns an array of update counts.
       * The <code>int</code> elements of the array that is returned are ordered
       * to correspond to the commands in the batch, which are ordered
       * according to the order in which they were added to the batch.
       * The elements in the array returned by the method <code>executeBatch</code>
       * may be one of the following:
       * <OL>
       * <LI>A number greater than or equal to zero -- indicates that the
       * command was processed successfully and is an update count giving the
       * number of rows in the database that were affected by the command's
       * execution
       * <LI>A value of <code>-2</code> -- indicates that the command was
       * processed successfully but that the number of rows affected is
       * unknown
       * <P>
       * If one of the commands in a batch update fails to execute properly,
       * this method throws a <code>BatchUpdateException</code>, and a JDBC
       * driver may or may not continue to process the remaining commands in
       * the batch.  However, the driver's behavior must be consistent with a
       * particular DBMS, either always continuing to process commands or never
       * continuing to process commands.  If the driver continues processing
       * after a failure, the array returned by the method
       * <code>BatchUpdateException.getUpdateCounts</code>
       * will contain as many elements as there are commands in the batch, and
       * at least one of the elements will be the following:
       * <P>
       * <LI>A value of <code>-3</code> -- indicates that the command failed
       * to execute successfully and occurs only if a driver continues to
       * process commands after a command fails
       * </OL>
       * <P>
   * A driver is not required to implement this method.
       * The possible implementations and return values have been modified in
       * the Java 2 SDK, Standard Edition, version 1.3 to
       * accommodate the option of continuing to proccess commands in a batch
       * update after a <code>BatchUpdateException</code> obejct has been thrown.
   *
   * @return an array of update counts containing one element for each
   * command in the batch.  The elements of the array are ordered according
   * to the order in which commands were added to the batch.
   * @exception SQLException if a database access error occurs or the
   * driver does not support batch statements. Throws {@link BatchUpdateException}
       * (a subclass of <code>SQLException</code>) if one of the commands sent to the
       * database fails to execute properly or attempts to return a result set.
   * @since 1.3
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public int[] executeBatch() throws SQLException {
    return getProxy().executeBatch();
  }

  public void setNull(int idx,int type,String typeName) throws SQLException
  {
    getProxy().setNull(idx,type,typeName);
  }
  public void setDate(int parameterIndex, java.sql.Date x,java.util.Calendar c) throws SQLException {
    getProxy().setDate(parameterIndex,x,c);
  }
  public void setTime(int parameterIndex, java.sql.Time x,java.util.Calendar c) throws SQLException {
    getProxy().setTime(parameterIndex,x,c);
  }
  public void setTimestamp(int parameterIndex, java.sql.Timestamp x,java.util.Calendar c) throws SQLException {
    getProxy().setTimestamp(parameterIndex,x,c);
  }

  /**
   * Registers the parameter in ordinal position
   * <code>parameterIndex</code> to be of JDBC type
   * <code>sqlType</code>.  This method must be called
   * before a stored procedure is executed.
   * <p>
   * The JDBC type specified by <code>sqlType</code> for an OUT
   * parameter determines the Java type that must be used
   * in the <code>get</code> method to read the value of that parameter.
   * <p>
   * This version of <code>registerOutParameter</code> should be
   * used when the parameter is of JDBC type <code>NUMERIC</code>
   * or <code>DECIMAL</code>.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @param sqlType SQL type code defined by <code>java.sql.Types</code>.
   * @param scale the desired number of digits to the right of the
   * decimal point.  It must be greater than or equal to zero.
   * @exception SQLException if a database access error occurs
   * @see Types
   */
  public void registerOutParameter(int parameterIndex, int sqlType, int scale) throws SQLException {
    getProxy().registerOutParameter(parameterIndex,sqlType,scale);
  }
  /**
   * Registers the OUT parameter in ordinal position
   * <code>parameterIndex</code> to the JDBC type
   * <code>sqlType</code>.  All OUT parameters must be registered
   * before a stored procedure is executed.
   * <p>
   * The JDBC type specified by <code>sqlType</code> for an OUT
   * parameter determines the Java type that must be used
   * in the <code>get</code> method to read the value of that parameter.
   * <p>
   * If the JDBC type expected to be returned to this output parameter
   * is specific to this particular database, <code>sqlType</code>
   * should be <code>java.sql.Types.OTHER</code>.  The method
   * {@link #getObject} retrieves the value.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @param sqlType the JDBC type code defined by <code>java.sql.Types</code>.
   * If the parameter is of JDBC type <code>NUMERIC</code>
   * or <code>DECIMAL</code>, the version of
   * <code>registerOutParameter</code> that accepts a scale value
   * should be used.
   * @exception SQLException if a database access error occurs
   * @see Types
   */
  public void registerOutParameter(int parameterIndex, int sqlType) throws SQLException {
    getProxy().registerOutParameter(parameterIndex,sqlType);
  }
  /**
   * Gets the value of a JDBC <code>FLOAT</code> parameter as a <code>float</code>
   * in the Java programming language.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result
   * is 0.
   * @exception SQLException if a database access error occurs
   */
  public float getFloat(int parameterIndex) throws SQLException {
    return getProxy().getFloat(parameterIndex);
  }
  /**
   * Gets the value of a JDBC <code>TINYINT</code> parameter as a <code>byte</code>
   * in the Java programming language.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result
   * is 0.
   * @exception SQLException if a database access error occurs
   */
  public byte getByte(int parameterIndex) throws SQLException {
    return getProxy().getByte(parameterIndex);
  }
  /**
   * Indicates whether or not the last OUT parameter read had the value of
   * SQL <code>NULL</code>.  Note that this method should be called only after
   * calling a <code>getXXX</code> method; otherwise, there is no value to use in
   * determining whether it is <code>null</code> or not.
   * @return <code>true</code> if the last parameter read was SQL
   * <code>NULL</code>; <code>false</code> otherwise
   * @exception SQLException if a database access error occurs
   */
  public boolean wasNull() throws SQLException {
    return getProxy().wasNull();
  }
  /**
   * Retrieves the value of a JDBC <code>CHAR</code>, <code>VARCHAR</code>,
   * or <code>LONGVARCHAR</code> parameter as a <code>String</code> in
   * the Java programming language.
   * <p>
   * For the fixed-length type JDBC <code>CHAR</code>,
   * the <code>String</code> object
   * returned has exactly the same value the JDBC
   * <code>CHAR</code> value had in the
   * database, including any padding added by the database.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value. If the value is SQL <code>NULL</code>, the result
   * is <code>null</code>.
   * @exception SQLException if a database access error occurs
   */
  public String getString(int parameterIndex) throws SQLException {
    return getProxy().getString(parameterIndex);
  }
  /**
   * Gets the value of a JDBC <code>BIT</code> parameter as a <code>boolean</code>
   * in the Java programming language.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result
   * is <code>false</code>.
   * @exception SQLException if a database access error occurs
   */
  public boolean getBoolean(int parameterIndex) throws SQLException {
    return getProxy().getBoolean(parameterIndex);
  }
  /**
   * Gets the value of a JDBC <code>DATE</code> parameter as a
   * <code>java.sql.Date</code> object.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result
   * is <code>null</code>.
   * @exception SQLException if a database access error occurs
   */
  public java.sql.Date getDate(int parameterIndex) throws SQLException {
    return getProxy().getDate(parameterIndex);
  }
  /**
   * Gets the value of a JDBC <code>SMALLINT</code> parameter as a <code>short</code>
   * in the Java programming language.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result
   * is 0.
   * @exception SQLException if a database access error occurs
   */
  public short getShort(int parameterIndex) throws SQLException {
    return getProxy().getShort(parameterIndex);
  }
  /**
   * Gets the value of a JDBC <code>INTEGER</code> parameter as an <code>int</code>
   * in the Java programming language.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result
   * is 0.
   * @exception SQLException if a database access error occurs
   */
  public int getInt(int parameterIndex) throws SQLException {
    return getProxy().getInt(parameterIndex);
  }
  /**
   * Gets the value of a JDBC <code>BIGINT</code> parameter as a <code>long</code>
   * in the Java programming language.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result
   * is 0.
   * @exception SQLException if a database access error occurs
   */
  public long getLong(int parameterIndex) throws SQLException {
    return getProxy().getLong(parameterIndex);
  }
  /**
   *
   * Gets the value of a JDBC <code>NUMERIC</code> parameter as a
   * <code>java.math.BigDecimal</code> object with as many digits to the
   * right of the decimal point as the value contains.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value in full precision.  If the value is
   * SQL <code>NULL</code>, the result is <code>null</code>.
   * @exception SQLException if a database access error occurs
  * @since 1.2
      * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
      */
  public BigDecimal getBigDecimal(int parameterIndex) throws SQLException {
    return getProxy().getBigDecimal(parameterIndex);
  }
  /**
   * Gets the value of a JDBC <code>DOUBLE</code> parameter as a <code>double</code>
     * in the Java programming language.
     * @param parameterIndex the first parameter is 1, the second is 2,
     * and so on
     * @return the parameter value.  If the value is SQL <code>NULL</code>, the result
     * is 0.
     * @exception SQLException if a database access error occurs
     */
  public double getDouble(int parameterIndex) throws SQLException {
    return getProxy().getDouble(parameterIndex);
  }
  /**
   * Gets the value of a JDBC <code>NUMERIC</code> parameter as a
   * <code>java.math.BigDecimal</code> object with scale digits to
   * the right of the decimal point.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @param scale the number of digits to the right of the decimal point
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result is
   * <code>null</code>.
   * @exception SQLException if a database access error occurs
   * @deprecated
   */
  public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException {
    return getProxy().getBigDecimal(parameterIndex);
  }
  /**
   * Gets the value of a JDBC <code>BINARY</code> or <code>VARBINARY</code>
   * parameter as an array of <code>byte</code> values in the Java
   * programming language.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result is
   *  <code>null</code>.
   * @exception SQLException if a database access error occurs
   */
  public byte[] getBytes(int parameterIndex) throws SQLException {
    return getProxy().getBytes(parameterIndex);
  }
  /**
   *
   * Gets the value of a JDBC <code>CLOB</code> parameter as a
   * <code>Clob</code> object in the Java programming language.
   * @param i the first parameter is 1, the second is 2, and
   * so on
   * @return the parameter value as a <code>Clob</code> object in the
   * Java programming language.  If the value was SQL <code>NULL</code>, the
   * value <code>null</code> is returned.
   * @exception SQLException if a database access error occurs
   * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
   */
  public Clob getClob(int i) throws SQLException {
    return getProxy().getClob(i);
  }
  /**
   * Get the value of a JDBC <code>TIME</code> parameter as a
   * <code>java.sql.Time</code> object.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result
   * is <code>null</code>.
   * @exception SQLException if a database access error occurs
   */
  public java.sql.Time getTime(int parameterIndex) throws SQLException {
    return getProxy().getTime(parameterIndex);
  }
  /**
   * Gets the value of a JDBC <code>TIMESTAMP</code> parameter as a
   * <code>java.sql.Timestamp</code> object.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value.  If the value is SQL <code>NULL</code>, the result
   * is <code>null</code>.
   * @exception SQLException if a database access error occurs
   */
  public java.sql.Timestamp getTimestamp(int parameterIndex) throws SQLException {
    return getProxy().getTimestamp(parameterIndex);
  }
  /**
   * Gets the value of a parameter as an <code>Object</code> in the Java
   * programming language.
   * <p>
   * This method returns a Java object whose type corresponds to the JDBC
   * type that was registered for this parameter using the method
   * <code>registerOutParameter</code>.  By registering the target JDBC
   * type as <code>java.sql.Types.OTHER</code>, this method can be used
   * to read database-specific abstract data types.
   * @param parameterIndex the first parameter is 1, the second is 2,
   * and so on
   * @return A <code>java.lang.Object</code> holding the OUT parameter value.
   * @exception SQLException if a database access error occurs
   * @see Types
   */
  public Object getObject(int parameterIndex) throws SQLException {
    return getProxy().getObject(parameterIndex);
  }
  /**
   *
   * Gets the value of a JDBC <code>REF(&lt;structured-type&gt;)</code>
   * parameter as a {@link Ref} object in the Java programming language.
   * @param i the first parameter is 1, the second is 2,
   * and so on
   * @return the parameter value as a <code>Ref</code> object in the
   * Java programming language.  If the value was SQL <code>NULL</code>, the value
   * <code>null</code> is returned.
   * @exception SQLException if a database access error occurs
  * @since 1.2
      * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
      */
  public Ref getRef(int i) throws SQLException {
    return getProxy().getRef(i);
  }
  /**
   *
   * Gets the value of a JDBC <code>BLOB</code> parameter as a
   * {@link Blob} object in the Java programming language.
   * @param i the first parameter is 1, the second is 2, and so on
   * @return the parameter value as a <code>Blob</code> object in the
   * Java programming language.  If the value was SQL <code>NULL</code>, the value
   * <code>null</code> is returned.
   * @exception SQLException if a database access error occurs
   * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
   */
  public Blob getBlob(int i) throws SQLException {
    return getProxy().getBlob(i);
  }
  /**
   *
   * Gets the value of a JDBC <code>ARRAY</code> parameter as an
   * {@link Array} object in the Java programming language.
   * @param i the first parameter is 1, the second is 2, and
   * so on
   * @return the parameter value as an <code>Array</code> object in
   * the Java programming language.  If the value was SQL <code>NULL</code>, the
   * value <code>null</code> is returned.
   * @exception SQLException if a database access error occurs
   * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
   */
  public Array getArray(int i) throws SQLException
  {
    return getProxy().getArray(i);
  }
  public Object getObject(int i, java.util.Map m)  throws SQLException
  {
    return getProxy().getObject(i,m);
  }

  public java.sql.Date getDate(int i, Calendar c)  throws SQLException
  {
    return getProxy().getDate(i,c);
  }
  public Time getTime(int i, Calendar c)  throws SQLException
  {
    return getProxy().getTime(i,c);
  }

  public Timestamp getTimestamp(int i, Calendar c)  throws SQLException
  {
    return getProxy().getTimestamp(i,c);
  }
  public void registerOutParameter(int i, int j, String s)  throws SQLException
  {
    getProxy().registerOutParameter(i,j,s);
  }


  // java 1.4 extensions
  // java 1.4 is not yet supported

  public void registerOutParameter(String parameterName,
  int sqlType)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }

  public void registerOutParameter(String parameterName,
  int sqlType,
  int scale)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void registerOutParameter(String parameterName,
  int sqlType,
  String typeName)
  throws SQLException

  {
  throw new SQLException("Not Implemented");
  }
  public URL getURL(int parameterIndex)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setURL(String parameterName,
  URL val)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setNull(String parameterName,
  int sqlType)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setBoolean(String parameterName,
  boolean x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setByte(String parameterName,
  byte x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setShort(String parameterName,
  short x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setInt(String parameterName,
  int x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setLong(String parameterName,
  long x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setFloat(String parameterName,
  float x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setDouble(String parameterName,
  double x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setBigDecimal(String parameterName,
  BigDecimal x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setString(String parameterName,
  String x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setBytes(String parameterName,
  byte[] x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setDate(String parameterName,
  java.sql.Date x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setTime(String parameterName,
  Time x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setTimestamp(String parameterName,
  Timestamp x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setAsciiStream(String parameterName,
  InputStream x,
  int length)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setBinaryStream(String parameterName,
  InputStream x,
  int length)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setObject(String parameterName,
  Object x,
  int targetSqlType,
  int scale)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setObject(String parameterName,
  Object x,
  int targetSqlType)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setObject(String parameterName,
  Object x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setCharacterStream(String parameterName,
  Reader reader,
  int length)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setDate(String parameterName,
  java.sql.Date x,
  Calendar cal)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setTime(String parameterName,
  Time x,
  Calendar cal)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setTimestamp(String parameterName,
  Timestamp x,
  Calendar cal)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public void setNull(String parameterName,
  int sqlType,
  String typeName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public String getString(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public boolean getBoolean(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public byte getByte(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public short getShort(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public int getInt(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public long getLong(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public float getFloat(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public double getDouble(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public byte[] getBytes(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public java.sql.Date getDate(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public Time getTime(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public Timestamp getTimestamp(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public Object getObject(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public BigDecimal getBigDecimal(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public Object getObject(String parameterName,
  Map map)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public Ref getRef(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public Blob getBlob(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public Clob getClob(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public Array getArray(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public java.sql.Date getDate(String parameterName,
  Calendar cal)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public Time getTime(String parameterName,
  Calendar cal)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public Timestamp getTimestamp(String parameterName,
  Calendar cal)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public URL getURL(String parameterName)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }






}
