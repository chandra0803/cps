/*
 *
 * $Id: OTPreparedStatement.java,v 1.2 2004/11/19 15:23:25 zz0qx3 Exp $
 * $Revision: 1.2 $
 * $Log: OTPreparedStatement.java,v $
 * Revision 1.2  2004/11/19 15:23:25  zz0qx3
 * added 1.4 required methods
 *
 * Revision 1.1  2004/08/23 20:30:25  vz86k2
 * check in
 *
 *
 */

package com.delphi.gfad.coreframework.db;

import java.sql.*;
import java.math.*;
import java.util.*;
import java.net.URL;
import java.io.*;

public class OTPreparedStatement implements PreparedStatement
{




  PreparedStatement proxy;
  boolean isCaching;

  public boolean isCaching()
  {
    return isCaching;
  }

  public OTPreparedStatement(PreparedStatement proxy,boolean isCaching)
  {
    this.proxy = proxy;
    this.isCaching = isCaching;
  }
  /**
   * Executes the SQL INSERT, UPDATE or DELETE statement
       * in this <code>PreparedStatement</code> object.
       * In addition,
   * SQL statements that return nothing, such as SQL DDL statements,
   * can be executed.
   *
   * @return either the row count for INSERT, UPDATE or DELETE statements;
       * or 0 for SQL statements that return nothing
   * @exception SQLException if a database access error occurs
   */
  public int executeUpdate() throws SQLException {
    return proxy.executeUpdate();
  }
  /**
       * Executes the SQL query in this <code>PreparedStatement</code> object
       * and returns the result set generated by the query.
   *
   * @return a <code>ResultSet</code> object that contains the data produced by the
   * query; never <code>null</code>
   * @exception SQLException if a database access error occurs
   */
  public ResultSet executeQuery() throws SQLException {
    return proxy.executeQuery();
  }
  /**
   * Sets the designated parameter to a Java <code>double</code> value.
       * The driver converts this
   * to an SQL <code>DOUBLE</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setDouble(int parameterIndex, double x) throws SQLException {
    proxy.setDouble(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java <code>short</code> value.
       * The driver converts this
   * to an SQL <code>SMALLINT</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setShort(int parameterIndex, short x) throws SQLException {
    proxy.setShort(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to SQL <code>NULL</code>.
   *
   * <P><B>Note:</B> You must specify the parameter's SQL type.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param sqlType the SQL type code defined in <code>java.sql.Types</code>
   * @exception SQLException if a database access error occurs
   */
  public void setNull(int parameterIndex, int sqlType) throws SQLException {
    proxy.setNull(parameterIndex,sqlType);
  }
  /**
   * Sets the designated parameter to a Java <code>boolean</code> value.
       * The driver converts this
   * to an SQL <code>BIT</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setBoolean(int parameterIndex, boolean x) throws SQLException {
    proxy.setBoolean(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java <code>byte</code> value.
       * The driver converts this
   * to an SQL <code>TINYINT</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setByte(int parameterIndex, byte x) throws SQLException {
    proxy.setByte(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a <code<java.sql.Date</code> value.
       * The driver converts this
   * to an SQL <code>DATE</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setDate(int parameterIndex, java.sql.Date x) throws SQLException {
    proxy.setDate(parameterIndex,x);
  }

  /**
   * Sets the designated parameter to a Java <code>int</code> value.
       * The driver converts this
   * to an SQL <code>INTEGER</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setInt(int parameterIndex, int x) throws SQLException {
    proxy.setInt(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java <code>long</code> value.
       * The driver converts this
   * to an SQL <code>BIGINT</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setLong(int parameterIndex, long x) throws SQLException {
    proxy.setLong(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java <code>float</code> value.
       * The driver converts this
   * to an SQL <code>FLOAT</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setFloat(int parameterIndex, float x) throws SQLException {
    proxy.setFloat(parameterIndex,x);
  }
  /**
       * Sets the designated parameter to the given input stream, which will have
       * the specified number of bytes.
   * When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
   * parameter, it may be more practical to send it via a
   * <code>java.io.InputStream</code> object. The data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from UNICODE to the database char format.
       * The byte format of the Unicode stream must be Java UTF-8, as
       * defined in the Java Virtual Machine Specification.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the java input stream which contains the
   * UNICODE parameter value
   * @param length the number of bytes in the stream
   * @exception SQLException if a database access error occurs
   * @deprecated
   */
  public void setUnicodeStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
    proxy.setUnicodeStream(parameterIndex,x,length);
  }
  /**
   * Sets the designated parameter to a <code>java.math.BigDecimal</code> value.
   * The driver converts this to an SQL <code>NUMERIC</code> value when
   * it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
    proxy.setBigDecimal(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java <code>String</code> value.
       * The driver converts this
   * to an SQL <code>VARCHAR</code> or <code>LONGVARCHAR</code> value
       * (depending on the argument's
   * size relative to the driver's limits on <code>VARCHAR</code> values)
       * when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setString(int parameterIndex, String x) throws SQLException {
    proxy.setString(parameterIndex,x);
  }
  /**
   * Sets the designated parameter to a Java array of bytes.  The driver converts
   * this to an SQL <code>VARBINARY</code> or <code>LONGVARBINARY</code>
       * (depending on the argument's size relative to the driver's limits on
       * <code>VARBINARY</code> values) when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setBytes(int parameterIndex, byte x[]) throws SQLException {
    proxy.setBytes(parameterIndex,x);
  }
  /**
        * Sets the value of the designated parameter with the given object.
    * This method is like the method <code>setObject</code>
        * above, except that it assumes a scale of zero.
    *
    * @param parameterIndex the first parameter is 1, the second is 2, ...
    * @param x the object containing the input parameter value
    * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
    *                      sent to the database
    * @exception SQLException if a database access error occurs
    */
  public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
    proxy.setObject(parameterIndex,x,targetSqlType);
  }
  /**
   * Sets the designated parameter to a <code>java.sql.Time</code> value.
       * The driver converts this
   * to an SQL <code>TIME</code> value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setTime(int parameterIndex, java.sql.Time x) throws SQLException {
    proxy.setTime(parameterIndex,x);
  }

  /**
   * Sets the designated parameter to a <code>java.sql.Timestamp</code> value.
       * The driver
   * converts this to an SQL <code>TIMESTAMP</code> value when it sends it to the
   * database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setTimestamp(int parameterIndex, java.sql.Timestamp x) throws SQLException {
    proxy.setTimestamp(parameterIndex,x);
  }
  /**
       * Sets the designated parameter to the given input stream, which will have
       * the specified number of bytes.
   * When a very large ASCII value is input to a <code>LONGVARCHAR</code>
   * parameter, it may be more practical to send it via a
   * <code>java.io.InputStream</code>. Data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from ASCII to the database char format.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the Java input stream that contains the ASCII parameter value
   * @param length the number of bytes in the stream
   * @exception SQLException if a database access error occurs
   */
  public void setAsciiStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
    proxy.setAsciiStream(parameterIndex,x,length);
  }
  /**
       * Sets the designated parameter to the given <code>Reader</code>
       * object, which is the given number of characters long.
   * When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
   * parameter, it may be more practical to send it via a
   * <code>java.io.Reader</code> object. The data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from UNICODE to the database char format.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the java reader which contains the UNICODE data
   * @param length the number of characters in the stream
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setCharacterStream(int parameterIndex, java.io.Reader reader, int length) throws SQLException {
    proxy.setCharacterStream(parameterIndex,reader,length);
  }
  /**
       * Sets the designated parameter to the given input stream, which will have
       * the specified number of bytes.
   * When a very large binary value is input to a <code>LONGVARBINARY</code>
   * parameter, it may be more practical to send it via a
   * <code>java.io.InputStream</code> object. The data will be read from the stream
   * as needed until end-of-file is reached.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the java input stream which contains the binary parameter value
   * @param length the number of bytes in the stream
   * @exception SQLException if a database access error occurs
   */
  public void setBinaryStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
    proxy.setBinaryStream(parameterIndex,x,length);
  }
  /**
       * Clears the current parameter values immediately.
   * <P>In general, parameter values remain in force for repeated use of a
   * statement. Setting a parameter value automatically clears its
   * previous value.  However, in some cases it is useful to immediately
   * release the resources used by the current parameter values; this can
   * be done by calling the method <code>clearParameters</code>.
   *
   * @exception SQLException if a database access error occurs
   */
  public void clearParameters() throws SQLException {
    proxy.clearParameters();
  }
  /**
   * <p>Sets the value of the designated parameter with the given object. The second
       * argument must be an object type; for integral values, the
   * <code>java.lang</code> equivalent objects should be used.
   *
   * <p>The given Java object will be converted to the given targetSqlType
   * before being sent to the database.
   *
   * If the object has a custom mapping (is of a class implementing the
       * interface <code>SQLData</code>),
   * the JDBC driver should call the method <code>SQLData.writeSQL</code> to write it
   * to the SQL data stream.
   * If, on the other hand, the object is of a class implementing
       * Ref, Blob, Clob, Struct,
   * or Array, the driver should pass it to the database as a value of the
   * corresponding SQL type.
   *
   * <p>Note that this method may be used to pass datatabase-
   * specific abstract data types.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the object containing the input parameter value
   * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
   * sent to the database. The scale argument may further qualify this type.
   * @param scale for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,
   *          this is the number of digits after the decimal point.  For all other
   *          types, this value will be ignored.
   * @exception SQLException if a database access error occurs
   * @see Types
   */
  public void setObject(int parameterIndex, Object x, int targetSqlType, int scale) throws SQLException {
    proxy.setObject(parameterIndex,x,targetSqlType,scale);
  }
  /**
   * Sets the designated parameter to the given
       *  <code>Array</code> object.
   * Sets an Array parameter.
   *
   * @param i the first parameter is 1, the second is 2, ...
   * @param x an <code>Array</code> object that maps an SQL <code>ARRAY</code> value
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setArray(int i, Array x) throws SQLException {
    proxy.setArray(i,x);
  }
  /**
   * <p>Sets the value of the designated parameter using the given object.
       * The second parameter must be of type <code>Object</code>; therefore, the
   * <code>java.lang</code> equivalent objects should be used for built-in types.
   *
   * <p>The JDBC specification specifies a standard mapping from
   * Java <code>Object</code> types to SQL types.  The given argument
   * will be converted to the corresponding SQL type before being
   * sent to the database.
   *
   * <p>Note that this method may be used to pass datatabase-
   * specific abstract data types, by using a driver-specific Java
   * type.
   *
   * If the object is of a class implementing the interface <code>SQLData</code>,
   * the JDBC driver should call the method <code>SQLData.writeSQL</code>
       * to write it to the SQL data stream.
   * If, on the other hand, the object is of a class implementing
       * Ref, Blob, Clob, Struct,
   * or Array, then the driver should pass it to the database as a value of the
   * corresponding SQL type.
   *
   * This method throws an exception if there is an ambiguity, for example, if the
   * object is of a class implementing more than one of the interfaces named above.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x the object containing the input parameter value
   * @exception SQLException if a database access error occurs
   */
  public void setObject(int parameterIndex, Object x) throws SQLException {
    proxy.setObject(parameterIndex,x);
  }
  /**
       * Executes any kind of SQL statement.
   * Some prepared statements return multiple results; the <code>execute</code>
   * method handles these complex statements as well as the simpler
   * form of statements handled by the methods <code>executeQuery</code>
       * and <code>executeUpdate</code>.
   *
   * @exception SQLException if a database access error occurs
   * @see Statement#execute
   */
  public boolean execute() throws SQLException {
    return proxy.execute();
  }
  /**
   * Adds a set of parameters to this <code>PreparedStatement</code>
       * object's batch of commands.
   *
   * @exception SQLException if a database access error occurs
   * @see Statement#addBatch
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void addBatch() throws SQLException {
    proxy.addBatch();
  }
  /**
   * Sets the designated parameter to the given
       *  <code>REF(&lt;structured-type&gt;)</code> value.
   *
   * @param i the first parameter is 1, the second is 2, ...
   * @param x an SQL <code>REF</code> value
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setRef(int i, Ref x) throws SQLException {
    proxy.setRef(i,x);
  }
  /**
   * Sets the designated parameter to the given
       *  <code>Blob</code> object.
   *
   * @param i the first parameter is 1, the second is 2, ...
   * @param x a <code>Blob</code> object that maps an SQL <code>BLOB</code> value
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setBlob(int i, Blob x) throws SQLException {
    proxy.setBlob(i,x);
  }
  /**
   * Sets the designated parameter to the given
       *  <code>Clob</code> object.
   *
   * @param i the first parameter is 1, the second is 2, ...
   * @param x a <code>Clob</code> object that maps an SQL <code>CLOB</code> value
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setClob(int i, Clob x) throws SQLException {
    proxy.setClob(i,x);
  }
  /**
   * Gets the number, types and properties of a <code>ResultSet</code>
       * object's columns.
   *
   * @return the description of a <code>ResultSet</code> object's columns
   * @exception SQLException if a database access error occurs
       * @since 1.2
   * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public ResultSetMetaData getMetaData() throws SQLException {
    return proxy.getMetaData();
  }
  /**
   * Executes an SQL statement that returns a single <code>ResultSet</code> object.
   *
   * @param sql typically this is a static SQL <code>SELECT</code> statement
   * @return a <code>ResultSet</code> object that contains the data produced by the
   * given query; never <code>null</code>
   * @exception SQLException if a database access error occurs
   */
  public ResultSet executeQuery(String sql) throws SQLException {
    return proxy.executeQuery(sql);
  }
  /**
   * Executes an SQL <code>INSERT</code>, <code>UPDATE</code> or
       * <code>DELETE</code> statement. In addition,
   * SQL statements that return nothing, such as SQL DDL statements,
   * can be executed.
   *
   * @param sql an SQL <code>INSERT</code>, <code>UPDATE</code> or
       * <code>DELETE</code> statement or an SQL statement that returns nothing
   * @return either the row count for <code>INSERT</code>, <code>UPDATE</code>
       * or <code>DELETE</code> statements, or 0 for SQL statements that return nothing
   * @exception SQLException if a database access error occurs
   */
  public int executeUpdate(String sql) throws SQLException {
    return proxy.executeUpdate(sql);
  }
  /**
   * Retrieves the maximum number of rows that a
   * <code>ResultSet</code> object can contain.  If the limit is exceeded, the excess
   * rows are silently dropped.
   *
   * @return the current max row limit; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public int getMaxRows() throws SQLException {
    return proxy.getMaxRows();
  }
  /**
       * Releases this <code>Statement</code> object's database
       * and JDBC resources immediately instead of waiting for
       * this to happen when it is automatically closed.
   * It is generally good practice to release resources as soon as
       * you are finished with them to avoid tying up database
       * resources.
   * <P><B>Note:</B> A <code>Statement</code> object is automatically closed when it is
   * garbage collected. When a <code>Statement</code> object is closed, its current
   * <code>ResultSet</code> object, if one exists, is also closed.
   *
   * @exception SQLException if a database access error occurs
   */
  public void close() throws SQLException {
    if(!isCaching())
      proxy.close();
  }
  /**
       * Sets escape processing on or off.
   * If escape scanning is on (the default), the driver will do
   * escape substitution before sending the SQL to the database.
   *
   * Note: Since prepared statements have usually been parsed prior
   * to making this call, disabling escape processing for prepared
   * statements will have no effect.
   *
   * @param enable <code>true</code> to enable; <code>false</code> to disable
   * @exception SQLException if a database access error occurs
   */
  public void setEscapeProcessing(boolean enable) throws SQLException {
    proxy.setEscapeProcessing(enable);
  }
  /**
   * Returns the maximum number of bytes allowed
   * for any column value.
       * This limit is the maximum number of bytes that can be
       * returned for any column value.
       * The limit applies only to <code>BINARY</code>,
   * <code>VARBINARY</code>, <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>, and <code>LONGVARCHAR</code>
   * columns.  If the limit is exceeded, the excess data is silently
   * discarded.
   *
   * @return the current max column size limit; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public int getMaxFieldSize() throws SQLException {
    return proxy.getMaxFieldSize();
  }
  /**
       * Sets the limit for the maximum number of bytes in a column to
       * the given number of bytes.  This is the maximum number of bytes
       * that can be returned for any column value.  This limit applies
       * only to <code>BINARY</code>, <code>VARBINARY</code>,
       * <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>, and
   * <code>LONGVARCHAR</code> fields.  If the limit is exceeded, the excess data
   * is silently discarded. For maximum portability, use values
   * greater than 256.
   *
   * @param max the new max column size limit; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public void setMaxFieldSize(int max) throws SQLException {
    proxy.setMaxFieldSize(max);
  }
  /**
   * Sets the number of seconds the driver will
   * wait for a <code>Statement</code> object to execute to the given number of seconds.
       * If the limit is exceeded, an <code>SQLException</code> is thrown.
   *
   * @param seconds the new query timeout limit in seconds; zero means
   * unlimited
   * @exception SQLException if a database access error occurs
   */
  public void setQueryTimeout(int seconds) throws SQLException {
    proxy.setQueryTimeout(seconds);
  }
  /**
   * Sets the limit for the maximum number of rows that any
   * <code>ResultSet</code> object can contain to the given number.
       * If the limit is exceeded, the excess
   * rows are silently dropped.
   *
   * @param max the new max rows limit; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public void setMaxRows(int max) throws SQLException {
    proxy.setMaxRows(max);
  }
  /**
   * Retrieves the first warning reported by calls on this <code>Statement</code> object.
   * Subsequent <code>Statement</code> object warnings will be chained to this
   * <code>SQLWarning</code> object.
   *
   * <p>The warning chain is automatically cleared each time
   * a statement is (re)executed.
   *
   * <P><B>Note:</B> If you are processing a <code>ResultSet</code> object, any
   * warnings associated with reads on that <code>ResultSet</code> object
       * will be chained on it.
   *
   * @return the first <code>SQLWarning</code> object or <code>null</code>
   * @exception SQLException if a database access error occurs
   */
  public SQLWarning getWarnings() throws SQLException {
    return proxy.getWarnings();
  }
  /**
       * Retrieves the number of seconds the driver will
   * wait for a <code>Statement</code> object to execute. If the limit is exceeded, a
   * <code>SQLException</code> is thrown.
   *
   * @return the current query timeout limit in seconds; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public int getQueryTimeout() throws SQLException {
    return proxy.getQueryTimeout();
  }
  /**
   * Defines the SQL cursor name that will be used by
   * subsequent <code>Statement</code> object <code>execute</code> methods.
       * This name can then be
   * used in SQL positioned update/delete statements to identify the
   * current row in the <code>ResultSet</code> object generated by this statement.  If
   * the database doesn't support positioned update/delete, this
   * method is a noop.  To insure that a cursor has the proper isolation
   * level to support updates, the cursor's <code>SELECT</code> statement should be
   * of the form 'select for update ...'. If the 'for update' phrase is
   * omitted, positioned updates may fail.
   *
   * <P><B>Note:</B> By definition, positioned update/delete
   * execution must be done by a different <code>Statement</code> object than the one
   * which generated the <code>ResultSet</code> object being used for positioning. Also,
   * cursor names must be unique within a connection.
   *
   * @param name the new cursor name, which must be unique within
       *             a connection
   * @exception SQLException if a database access error occurs
   */
  public void setCursorName(String name) throws SQLException {
    proxy.setCursorName(name);
  }
  /**
       * Cancels this <code>Statement</code> object if both the DBMS and
       * driver support aborting an SQL statement.
   * This method can be used by one thread to cancel a statement that
   * is being executed by another thread.
   *
   * @exception SQLException if a database access error occurs
   */
  public void cancel() throws SQLException {
    proxy.cancel();
  }
  /**
   *  Returns the current result as a <code>ResultSet</code> object.
   *  This method should be called only once per result.
   *
   * @return the current result as a <code>ResultSet</code> object;
       * <code>null</code> if the result is an update count or there are no more results
   * @exception SQLException if a database access error occurs
   * @see #execute
   */
  public ResultSet getResultSet() throws SQLException {
    return proxy.getResultSet();
  }
  /**
       * Clears all the warnings reported on this <code>Statement</code>
       * object. After a call to this method,
       * the method <code>getWarnings</code> will return
       * <code>null</code> until a new warning is reported for this
       * <code>Statement</code> object.
   *
   * @exception SQLException if a database access error occurs
   */
  public void clearWarnings() throws SQLException {
    proxy.clearWarnings();
  }
  /**
   * Moves to a <code>Statement</code> object's next result.  It returns
       * <code>true</code> if this result is a <code>ResultSet</code> object.
       * This method also implicitly closes any current <code>ResultSet</code>
       * object obtained with the method <code>getResultSet</code>.
   *
   * <P>There are no more results when the following is true:
       * <PRE>
       *      <code>(!getMoreResults() && (getUpdateCount() == -1)</code>
       * </PRE>
   *
   * @return <code>true</code> if the next result is a <code>ResultSet</code> object;
       * <code>false</code> if it is an update count or there are no more results
   * @exception SQLException if a database access error occurs
   * @see #execute
   */
  public boolean getMoreResults() throws SQLException {
    return proxy.getMoreResults();
  }
  /**
   * Executes an SQL statement that may return multiple results.
   * Under some (uncommon) situations a single SQL statement may return
   * multiple result sets and/or update counts.  Normally you can ignore
   * this unless you are (1) executing a stored procedure that you know may
   * return multiple results or (2) you are dynamically executing an
   * unknown SQL string.  The  methods <code>execute</code>,
       * <code>getMoreResults</code>, <code>getResultSet</code>,
   * and <code>getUpdateCount</code> let you navigate through multiple results.
   *
   * The <code>execute</code> method executes an SQL statement and indicates the
   * form of the first result.  You can then use the methods
       * <code>getResultSet</code> or <code>getUpdateCount</code>
       * to retrieve the result, and <code>getMoreResults</code> to
   * move to any subsequent result(s).
   *
   * @param sql any SQL statement
   * @return <code>true</code> if the next result is a <code>ResultSet</code> object;
       * <code>false</code> if it is an update count or there are no more results
   * @exception SQLException if a database access error occurs
   * @see #getResultSet
   * @see #getUpdateCount
   * @see #getMoreResults
   */
  public boolean execute(String sql) throws SQLException {
    return proxy.execute(sql);
  }
  /**
   * Retrieves the direction for fetching rows from
       * database tables that is the default for result sets
       * generated from this <code>Statement</code> object.
       * If this <code>Statement</code> object has not set
       * a fetch direction by calling the method <code>setFetchDirection</code>,
       * the return value is implementation-specific.
   *
   * @return the default fetch direction for result sets generated
       *          from this <code>Statement</code> object
   * @exception SQLException if a database access error occurs
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public int getFetchDirection() throws SQLException {
    return proxy.getFetchDirection();
  }
  /**
   *  Returns the current result as an update count;
   *  if the result is a <code>ResultSet</code> object or there are no more results, -1
   *  is returned. This method should be called only once per result.
   *
   * @return the current result as an update count; -1 if the current result is a
   * <code>ResultSet</code> object or there are no more results
   * @exception SQLException if a database access error occurs
   * @see #execute
   */
  public int getUpdateCount() throws SQLException {
    return proxy.getUpdateCount();
  }
  /**
   * Retrieves the number of result set rows that is the default
       * fetch size for result sets
       * generated from this <code>Statement</code> object.
       * If this <code>Statement</code> object has not set
       * a fetch size by calling the method <code>setFetchSize</code>,
       * the return value is implementation-specific.
   * @return the default fetch size for result sets generated
       *          from this <code>Statement</code> object
   * @exception SQLException if a database access error occurs
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public int getFetchSize() throws SQLException {
    return proxy.getFetchSize();
  }
  /**
   * Gives the driver a hint as to the direction in which
       * the rows in a result set
   * will be processed. The hint applies only to result sets created
   * using this <code>Statement</code> object.  The default value is
   * <code>ResultSet.FETCH_FORWARD</code>.
   * <p>Note that this method sets the default fetch direction for
       * result sets generated by this <code>Statement</code> object.
       * Each result set has its own methods for getting and setting
       * its own fetch direction.
   * @param direction the initial direction for processing rows
   * @exception SQLException if a database access error occurs
       * or the given direction
   * is not one of <code>ResultSet.FETCH_FORWARD</code>,
       * <code>ResultSet.FETCH_REVERSE</code>, or <code>ResultSet.FETCH_UNKNOWN</code>
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setFetchDirection(int direction) throws SQLException {
    proxy.setFetchDirection(direction);
  }
  /**
   * Retrieves the result set type for <code>ResultSet</code> objects
       * generated by this <code>Statement</code> object.
       *
       * @return one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
       * <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
       * <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public int getResultSetType() throws SQLException {
    return proxy.getResultSetType();
  }
  /**
   * Gives the JDBC driver a hint as to the number of rows that should
   * be fetched from the database when more rows are needed.  The number
   * of rows specified affects only result sets created using this
   * statement. If the value specified is zero, then the hint is ignored.
   * The default value is zero.
   *
   * @param rows the number of rows to fetch
   * @exception SQLException if a database access error occurs, or the
   * condition 0 <= rows <= this.getMaxRows() is not satisfied.
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void setFetchSize(int rows) throws SQLException {
    proxy.setFetchSize(rows);
  }
  /**
   * Makes the set of commands in the current batch empty.
   * This method is optional.
   *
   * @exception SQLException if a database access error occurs or the
   * driver does not support batch statements
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void clearBatch() throws SQLException {
    proxy.clearBatch();
  }
  /**
   * Retrieves the result set concurrency for <code>ResultSet</code> objects
       * generated by this <code>Statement</code> object.
       *
       * @return either <code>ResultSet.CONCUR_READ_ONLY</code> or
       * <code>ResultSet.CONCUR_UPDATABLE</code>
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public int getResultSetConcurrency() throws SQLException {
    return proxy.getResultSetConcurrency();
  }
  /**
   * Returns the <code>Connection</code> object
       * that produced this <code>Statement</code> object.
       * @return the connection that produced this statement
   * @exception SQLException if a database access error occurs
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public Connection getConnection() throws SQLException {
    return proxy.getConnection();
  }
  /**
   * Adds an SQL command to the current batch of commmands for this
       * <code>Statement</code> object. This method is optional.
   *
   * @param sql typically this is a static SQL <code>INSERT</code> or
       * <code>UPDATE</code> statement
   * @exception SQLException if a database access error occurs, or the
   * driver does not support batch statements
   * @since 1.2
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public void addBatch(String sql) throws SQLException {
    proxy.addBatch(sql);
  }
  /**
   * Submits a batch of commands to the database for execution and
       * if all commands execute successfully, returns an array of update counts.
       * The <code>int</code> elements of the array that is returned are ordered
       * to correspond to the commands in the batch, which are ordered
       * according to the order in which they were added to the batch.
       * The elements in the array returned by the method <code>executeBatch</code>
       * may be one of the following:
       * <OL>
       * <LI>A number greater than or equal to zero -- indicates that the
       * command was processed successfully and is an update count giving the
       * number of rows in the database that were affected by the command's
       * execution
       * <LI>A value of <code>-2</code> -- indicates that the command was
       * processed successfully but that the number of rows affected is
       * unknown
       * <P>
       * If one of the commands in a batch update fails to execute properly,
       * this method throws a <code>BatchUpdateException</code>, and a JDBC
       * driver may or may not continue to process the remaining commands in
       * the batch.  However, the driver's behavior must be consistent with a
       * particular DBMS, either always continuing to process commands or never
       * continuing to process commands.  If the driver continues processing
       * after a failure, the array returned by the method
       * <code>BatchUpdateException.getUpdateCounts</code>
       * will contain as many elements as there are commands in the batch, and
       * at least one of the elements will be the following:
       * <P>
       * <LI>A value of <code>-3</code> -- indicates that the command failed
       * to execute successfully and occurs only if a driver continues to
       * process commands after a command fails
       * </OL>
       * <P>
   * A driver is not required to implement this method.
       * The possible implementations and return values have been modified in
       * the Java 2 SDK, Standard Edition, version 1.3 to
       * accommodate the option of continuing to proccess commands in a batch
       * update after a <code>BatchUpdateException</code> obejct has been thrown.
   *
   * @return an array of update counts containing one element for each
   * command in the batch.  The elements of the array are ordered according
   * to the order in which commands were added to the batch.
   * @exception SQLException if a database access error occurs or the
   * driver does not support batch statements. Throws {@link BatchUpdateException}
       * (a subclass of <code>SQLException</code>) if one of the commands sent to the
       * database fails to execute properly or attempts to return a result set.
   * @since 1.3
       * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
       *      2.0 API</a>
   */
  public int[] executeBatch() throws SQLException {
    return proxy.executeBatch();
  }

  public void setNull(int idx,int type,String typeName) throws SQLException
  {
    proxy.setNull(idx,type,typeName);
  }
  public void setDate(int parameterIndex, java.sql.Date x,java.util.Calendar c) throws SQLException {
    proxy.setDate(parameterIndex,x,c);
  }
  public void setTime(int parameterIndex, java.sql.Time x,java.util.Calendar c) throws SQLException {
    proxy.setTime(parameterIndex,x,c);
  }
  public void setTimestamp(int parameterIndex, java.sql.Timestamp x,java.util.Calendar c) throws SQLException {
    proxy.setTimestamp(parameterIndex,x,c);
  }


  // 1.4 extensions
  public void setURL(int parameterIndex, URL x)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public ParameterMetaData getParameterMetaData()
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }

  public boolean getMoreResults(int current)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public ResultSet getGeneratedKeys()
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public int executeUpdate(String sql,
  int autoGeneratedKeys)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public int executeUpdate(String sql,
  int[] columnIndexes)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public int executeUpdate(String sql,
  String[] columnNames)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public boolean execute(String sql,
  int autoGeneratedKeys)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public boolean execute(String sql,
  int[] columnIndexes)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public boolean execute(String sql,
  String[] columnNames)
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }
  public int getResultSetHoldability()
  throws SQLException
  {
  throw new SQLException("Not Implemented");
  }


}
